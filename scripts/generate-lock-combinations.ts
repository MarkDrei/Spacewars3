#!/usr/bin/env node
// Generate all lock combinations for specified locks
// Domain-agnostic: uses only lock numbers, not domain-specific names

import { writeFileSync } from 'fs';

const LOCKS = [2, 4, 6, 8, 10] as const;

// Generate all non-empty subsets
function generateAllSubsets<T>(arr: T[]): T[][] {
  const result: T[][] = [];
  const n = arr.length;
  
  // Iterate through all possible combinations (2^n - 1, excluding empty set)
  for (let i = 1; i < (1 << n); i++) {
    const subset: T[] = [];
    for (let j = 0; j < n; j++) {
      if (i & (1 << j)) {
        subset.push(arr[j]);
      }
    }
    result.push(subset);
  }
  
  return result;
}

// Generate the TypeScript code
function generateLockCombinationsFile(): string {
  const subsets = generateAllSubsets([...LOCKS]);
  
  let code = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: scripts/generate-lock-combinations.ts
// 
// This file contains all valid lock combinations.
// Locks used: ${LOCKS.join(', ')}
// Total combinations: ${subsets.length}

import { type LockContext as IronGuardLockContext } from '@markdrei/ironguard-typescript-locks';

// ===== INDIVIDUAL LOCK TYPES =====

`;

  // Generate individual lock types
  for (const lock of LOCKS) {
    code += `/** Context holding ONLY lock ${lock} */\n`;
    code += `export type Only${lock} = IronGuardLockContext<readonly [${lock}]>;\n\n`;
  }

  code += `// ===== ALL COMBINATIONS =====\n\n`;

  // Generate type for each combination
  for (const subset of subsets) {
    const lockNumbers = subset.join(', ');
    const typeName = `Locks${subset.join('_')}`;
    
    code += `/** Context holding locks: [${lockNumbers}] */\n`;
    code += `export type ${typeName} = IronGuardLockContext<readonly [${lockNumbers}]>;\n\n`;
  }

  // Generate union of all combinations
  code += `// ===== UNION OF ALL VALID COMBINATIONS =====

/**
 * Union of all ${subsets.length} valid lock combinations.
 * Use this when you want to accept any valid combination of locks.
 */
export type AnyValidLockCombination =\n`;
  
  for (let i = 0; i < subsets.length; i++) {
    const subset = subsets[i];
    const typeName = `Locks${subset.join('_')}`;
    const prefix = i === 0 ? '  ' : '  | ';
    const suffix = i === subsets.length - 1 ? ';\n' : '\n';
    code += `${prefix}${typeName}${suffix}`;
  }

  // Generate groupings for each lock
  code += `\n// ===== LOCK-SPECIFIC GROUPINGS =====\n`;
  
  for (const lock of LOCKS) {
    code += `\n/** Contexts that include lock ${lock} */\n`;
    code += `export type With${lock} =\n`;
    
    const withLock = subsets.filter(s => s.includes(lock));
    for (let i = 0; i < withLock.length; i++) {
      const subset = withLock[i];
      const typeName = `Locks${subset.join('_')}`;
      const prefix = i === 0 ? '  ' : '  | ';
      const suffix = i === withLock.length - 1 ? ';\n' : '\n';
      code += `${prefix}${typeName}${suffix}`;
    }
  }

  // Add summary comment
  code += `
// ===== STATISTICS =====
// Total lock combinations: ${subsets.length}
// - Single locks: ${subsets.filter(s => s.length === 1).length}
// - Pairs: ${subsets.filter(s => s.length === 2).length}
// - Triples: ${subsets.filter(s => s.length === 3).length}
// - Quadruples: ${subsets.filter(s => s.length === 4).length}
// - All five: ${subsets.filter(s => s.length === 5).length}
`;

  return code;
}

// Generate and write the file
const code = generateLockCombinationsFile();
const outputPath = 'src/lib/server/generatedLockCombinations.ts';

writeFileSync(outputPath, code, 'utf-8');

console.log(`âœ… Generated ${outputPath}`);
console.log(`ðŸ“Š Created 31 lock combination types`);
console.log(`ðŸŽ¯ Use these types for exact lock matching!`);
